\doxysection{mutex\+\_\+create\+\_\+static}
\hypertarget{group__mutex__create__static}{}\label{group__mutex__create__static}\index{mutex\_create\_static@{mutex\_create\_static}}
semphr. h 
\begin{DoxyPre}sem\_t mutex\_create\_static( static\_sem\_s\_t *pxMutexBuffer )\end{DoxyPre}


Creates a new mutex type semaphore instance, and returns a handle by which the new mutex can be referenced.

Internally, within the Free\+RTOS implementation, mutex semaphores use a block of memory, in which the mutex structure is stored. If a mutex is created using \doxylink{group__c-rtos_ga475d096afa3abcc9a276ca9fa54bafdf}{mutex\+\_\+create()} then the required memory is automatically dynamically allocated inside the \doxylink{group__c-rtos_ga475d096afa3abcc9a276ca9fa54bafdf}{mutex\+\_\+create()} function. (see \href{http://www.freertos.org/a00111.html}{\texttt{ http\+://www.\+freertos.\+org/a00111.\+html}}). If a mutex is created using mutex\+\_\+create\+\_\+static() then the application writer must provided the memory. mutex\+\_\+create\+\_\+static() therefore allows a mutex to be created without using any dynamic memory allocation.

Mutexes created using this function can be accessed using the \doxylink{group__apix_gaee36a9729a21b6ad0de78985a16c4f03}{sem\+\_\+wait()} and \doxylink{group__apix_gaa2048694c50246f193a40b7e00ed1756}{sem\+\_\+post()} macros. The \doxylink{group__c-rtos_ga67f8421ccecb58c807762494efe10c3a}{mutex\+\_\+recursive\+\_\+take()} and \doxylink{group__c-rtos_gaaf82d93cd652b6173372970018fdc02d}{mutex\+\_\+recursive\+\_\+give()} macros must not be used.

This type of semaphore uses a priority inheritance mechanism so a task \textquotesingle{}taking\textquotesingle{} a semaphore MUST ALWAYS \textquotesingle{}give\textquotesingle{} the semaphore back once the semaphore it is no longer required.

Mutex type semaphores cannot be used from within interrupt service routines.

See \doxylink{group__apix_ga83c9a6c93e3bfce8f36e3f32a6dc8c4b}{sem\+\_\+binary\+\_\+create()} for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always \textquotesingle{}gives\textquotesingle{} the semaphore and another always \textquotesingle{}takes\textquotesingle{} the semaphore) and from within interrupt service routines.


\begin{DoxyParams}{Parameters}
{\em px\+Mutex\+Buffer} & Must point to a variable of type static\+\_\+sem\+\_\+s\+\_\+t, which will be used to hold the mutex\textquotesingle{}s data structure, removing the need for the memory to be allocated dynamically.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the mutex was successfully created then a handle to the created mutex is returned. If px\+Mutex\+Buffer was NULL then NULL is returned.
\end{DoxyReturn}
Example usage\+: 
\begin{DoxyPre}
sem\_t xSemaphore;
static\_sem\_s\_t xMutexBuffer;

void vATask( void * pvParameters )
\{
   // A mutex cannot be used before it has been created.  xMutexBuffer is
   // into mutex\_create\_static() so no dynamic memory allocation is
   // attempted.
   xSemaphore = mutex\_create\_static( \&xMutexBuffer );

   // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
   // so there is no need to check it.
\}
\end{DoxyPre}
 