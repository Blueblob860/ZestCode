\doxysection{C\+:/\+Users/leoku/\+One\+Drive/\+Personal\+\_\+\+Coding\+\_\+\+Projects/\+Zest\+Code/src/devices/vdml.c File Reference}
\hypertarget{vdml_8c}{}\label{vdml_8c}\index{C:/Users/leoku/OneDrive/Personal\_Coding\_Projects/ZestCode/src/devices/vdml.c@{C:/Users/leoku/OneDrive/Personal\_Coding\_Projects/ZestCode/src/devices/vdml.c}}
{\ttfamily \#include "{}vdml/vdml.\+h"{}}\newline
{\ttfamily \#include "{}kapi.\+h"{}}\newline
{\ttfamily \#include "{}v5\+\_\+api.\+h"{}}\newline
{\ttfamily \#include "{}vdml/registry.\+h"{}}\newline
{\ttfamily \#include $<$errno.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{vdml_8c_ac0a4dd723c8257decf13d08539e9e84c}\label{vdml_8c_ac0a4dd723c8257decf13d08539e9e84c} 
void {\bfseries registry\+\_\+init} ()
\item 
void \mbox{\hyperlink{vdml_8c_a96e75a6ca5696c0f58261ae0a5648b7a}{port\+\_\+mutex\+\_\+init}} ()
\item 
int32\+\_\+t \mbox{\hyperlink{vdml_8c_a0086020993f44c165e8e2a6cd7e5eeaa}{claim\+\_\+port\+\_\+try}} (uint8\+\_\+t port, v5\+\_\+device\+\_\+e\+\_\+t type)
\item 
void \mbox{\hyperlink{vdml_8c_a285725607b31dfc76174f7e4569c3f84}{vdml\+\_\+initialize}} ()
\item 
int \mbox{\hyperlink{vdml_8c_a67513439eb7264d1196f58dbaa03c847}{port\+\_\+mutex\+\_\+take}} (uint8\+\_\+t port)
\item 
int \mbox{\hyperlink{vdml_8c_af35fba308dec7fbae265a4b4586a4786}{internal\+\_\+port\+\_\+mutex\+\_\+take}} (uint8\+\_\+t port)
\item 
int \mbox{\hyperlink{vdml_8c_abeb38b74fc71b8003c53e920822f7d1d}{port\+\_\+mutex\+\_\+give}} (uint8\+\_\+t port)
\item 
int \mbox{\hyperlink{vdml_8c_a3cd0d28bdfcb9c15a2bd393a25fcb6f2}{internal\+\_\+port\+\_\+mutex\+\_\+give}} (uint8\+\_\+t port)
\item 
void \mbox{\hyperlink{vdml_8c_a00133d1eced9193949574829587a393d}{port\+\_\+mutex\+\_\+take\+\_\+all}} ()
\item 
void \mbox{\hyperlink{vdml_8c_ae70eb480db1d80602e5b5f037d572d47}{port\+\_\+mutex\+\_\+give\+\_\+all}} ()
\item 
void \mbox{\hyperlink{vdml_8c_ab164b06ea2d6c77fac6d1afc8bfa78f4}{vdml\+\_\+set\+\_\+port\+\_\+error}} (uint8\+\_\+t port)
\item 
void \mbox{\hyperlink{vdml_8c_a041f91b4d998392918864e26df946f32}{vdml\+\_\+unset\+\_\+port\+\_\+error}} (uint8\+\_\+t port)
\item 
bool \mbox{\hyperlink{vdml_8c_a9b8bc94d616e0f915c2930698e64c4bc}{vdml\+\_\+get\+\_\+port\+\_\+error}} (uint8\+\_\+t port)
\item 
void \mbox{\hyperlink{vdml_8c_aee1773d8eb981f08d1c33618106134ce}{vdml\+\_\+background\+\_\+processing}} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
int32\+\_\+t \mbox{\hyperlink{vdml_8c_a93dbe5adaa0d9331b7a02a713da023c1}{port\+\_\+errors}}
\item 
\mbox{\hyperlink{group__c-rtos_gab15ea84d90257d70b44e8e04519864d2}{mutex\+\_\+t}} \mbox{\hyperlink{vdml_8c_a234bd81f117a6313d45285d9fb6745f0}{port\+\_\+mutexes}} \mbox{[}V5\+\_\+\+MAX\+\_\+\+DEVICE\+\_\+\+PORTS\mbox{]}
\item 
\Hypertarget{vdml_8c_a90d1eabbf9b0d96290279cd8fce35877}\label{vdml_8c_a90d1eabbf9b0d96290279cd8fce35877} 
\mbox{\hyperlink{structx_s_t_a_t_i_c___q_u_e_u_e}{static\+\_\+sem\+\_\+s\+\_\+t}} {\bfseries port\+\_\+mutex\+\_\+bufs} \mbox{[}V5\+\_\+\+MAX\+\_\+\+DEVICE\+\_\+\+PORTS\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
VDML -\/ VEX Data Management Layer

VDML ensures thread saftey for operations on smart devices by maintaining an array of RTOS Mutexes and implementing functions to take and give them.

\begin{DoxyCopyright}{Copyright}
Copyright (c) 2017-\/2024, Purdue University ACM SIGBots.
\end{DoxyCopyright}
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.\+0. If a copy of the MPL was not distributed with this file, You can obtain one at \href{http://mozilla.org/MPL/2.0/}{\texttt{ http\+://mozilla.\+org/\+MPL/2.\+0/}}. 

\doxysubsection{Function Documentation}
\Hypertarget{vdml_8c_a0086020993f44c165e8e2a6cd7e5eeaa}\index{vdml.c@{vdml.c}!claim\_port\_try@{claim\_port\_try}}
\index{claim\_port\_try@{claim\_port\_try}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{claim\_port\_try()}{claim\_port\_try()}}
{\footnotesize\ttfamily \label{vdml_8c_a0086020993f44c165e8e2a6cd7e5eeaa} 
int32\+\_\+t claim\+\_\+port\+\_\+try (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{port}{, }\item[{v5\+\_\+device\+\_\+e\+\_\+t}]{type}{}\end{DoxyParamCaption})}

A function that executes claim\+\_\+port and allows you to execute a block of code if an error occurs.

This function uses the following values of errno when an error state is reached\+: ENXIO -\/ The given value is not within the range of V5 ports (1-\/21). EACCES -\/ Another resource is currently trying to access the port.


\begin{DoxyParams}{Parameters}
{\em port} & The V5 port number from 0-\/20 \\
\hline
{\em device\+\_\+type} & The v5\+\_\+device\+\_\+e\+\_\+t that the port is configured as\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if the operation was successful or 0 if the operation failed, setting errno. 
\end{DoxyReturn}
\Hypertarget{vdml_8c_a3cd0d28bdfcb9c15a2bd393a25fcb6f2}\index{vdml.c@{vdml.c}!internal\_port\_mutex\_give@{internal\_port\_mutex\_give}}
\index{internal\_port\_mutex\_give@{internal\_port\_mutex\_give}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{internal\_port\_mutex\_give()}{internal\_port\_mutex\_give()}}
{\footnotesize\ttfamily \label{vdml_8c_a3cd0d28bdfcb9c15a2bd393a25fcb6f2} 
int internal\+\_\+port\+\_\+mutex\+\_\+give (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{port}{}\end{DoxyParamCaption})}

Returns a port mutex with bounds checking for V5\+\_\+\+MAX\+\_\+\+PORTS (32) not user exposed device ports (20). Intended for internal usage for protecting thread-\/safety on devices such as the controller and battery

This function uses the following values of errno when an error state is reached\+: ENXIO -\/ The given value is not within the range of V5 ports (0-\/32).


\begin{DoxyParams}{Parameters}
{\em port} & The V5 port number from 0-\/32\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the mutex was successfully returned, false otherwise. If false is returned, then errno is set with a hint about why the mutex couldn\textquotesingle{}t be returned. 
\end{DoxyReturn}
\Hypertarget{vdml_8c_af35fba308dec7fbae265a4b4586a4786}\index{vdml.c@{vdml.c}!internal\_port\_mutex\_take@{internal\_port\_mutex\_take}}
\index{internal\_port\_mutex\_take@{internal\_port\_mutex\_take}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{internal\_port\_mutex\_take()}{internal\_port\_mutex\_take()}}
{\footnotesize\ttfamily \label{vdml_8c_af35fba308dec7fbae265a4b4586a4786} 
int internal\+\_\+port\+\_\+mutex\+\_\+take (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{port}{}\end{DoxyParamCaption})}

Obtains a port mutex with bounds checking for V5\+\_\+\+MAX\+\_\+\+PORTS (32) not user exposed device ports (20). Intended for internal usage for protecting thread-\/safety on devices such as the controller and battery

This function uses the following values of errno when an error state is reached\+: ENXIO -\/ The given value is not within the range of V5 ports (0-\/32).


\begin{DoxyParams}{Parameters}
{\em port} & The V5 port number from 0-\/32\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the mutex was successfully taken, false otherwise. If false is returned, then errno is set with a hint about why the the mutex couldn\textquotesingle{}t be taken. 
\end{DoxyReturn}
\Hypertarget{vdml_8c_abeb38b74fc71b8003c53e920822f7d1d}\index{vdml.c@{vdml.c}!port\_mutex\_give@{port\_mutex\_give}}
\index{port\_mutex\_give@{port\_mutex\_give}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{port\_mutex\_give()}{port\_mutex\_give()}}
{\footnotesize\ttfamily \label{vdml_8c_abeb38b74fc71b8003c53e920822f7d1d} 
int port\+\_\+mutex\+\_\+give (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{port}{}\end{DoxyParamCaption})}

Returns the mutex for the given port.

Frees the mutex for this port, allowing other tasks to continue.

WARNING\+: If a mutex was claimed by a task, this MUST be called immediately after the port is no longer needed by that task in order to prevent delays in other tasks.

This function uses the following values of errno when an error state is reached\+: ENXIO -\/ The given value is not within the range of V5 ports (0-\/20).


\begin{DoxyParams}{Parameters}
{\em port} & The V5 port number to free from 0-\/20 \\
\hline
\end{DoxyParams}
\Hypertarget{vdml_8c_ae70eb480db1d80602e5b5f037d572d47}\index{vdml.c@{vdml.c}!port\_mutex\_give\_all@{port\_mutex\_give\_all}}
\index{port\_mutex\_give\_all@{port\_mutex\_give\_all}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{port\_mutex\_give\_all()}{port\_mutex\_give\_all()}}
{\footnotesize\ttfamily \label{vdml_8c_ae70eb480db1d80602e5b5f037d572d47} 
void port\+\_\+mutex\+\_\+give\+\_\+all (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Executes \doxylink{vdml_8h_abeb38b74fc71b8003c53e920822f7d1d}{port\+\_\+mutex\+\_\+give()} for all of the V5 Smart Ports. \Hypertarget{vdml_8c_a96e75a6ca5696c0f58261ae0a5648b7a}\index{vdml.c@{vdml.c}!port\_mutex\_init@{port\_mutex\_init}}
\index{port\_mutex\_init@{port\_mutex\_init}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{port\_mutex\_init()}{port\_mutex\_init()}}
{\footnotesize\ttfamily \label{vdml_8c_a96e75a6ca5696c0f58261ae0a5648b7a} 
void port\+\_\+mutex\+\_\+init (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [extern]}}

Initializes the mutexes for the motor ports.

Initializes a static array of Free\+RTOS mutexes to protect against race conditions. For example, we don\textquotesingle{}t want the Background processing task to run at the same time that we set a motor, because bad information may be returned, or worse. \Hypertarget{vdml_8c_a67513439eb7264d1196f58dbaa03c847}\index{vdml.c@{vdml.c}!port\_mutex\_take@{port\_mutex\_take}}
\index{port\_mutex\_take@{port\_mutex\_take}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{port\_mutex\_take()}{port\_mutex\_take()}}
{\footnotesize\ttfamily \label{vdml_8c_a67513439eb7264d1196f58dbaa03c847} 
int port\+\_\+mutex\+\_\+take (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{port}{}\end{DoxyParamCaption})}

Claims the mutex for the given port.

Reserves the mutex for this port. Any other tasks trying to access this port will block until the mutex is returned. If a higher-\/priortiy task attempts to claim this port, the task which has the port claimed will temporarily be raised to an equal priority until the mutex is given, reducing the impact of the delay. See Free\+RTOS documentation for more details.

This MUST be called before any call to the v5 api to maintain thread saftey.

This function uses the following values of errno when an error state is reached\+: ENXIO -\/ The given value is not within the range of V5 ports (0-\/20).


\begin{DoxyParams}{Parameters}
{\em port} & The V5 port number to claim from 0-\/20\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if the mutex was successfully taken, 0 if not, -\/1 if port is invalid. 
\end{DoxyReturn}
\Hypertarget{vdml_8c_a00133d1eced9193949574829587a393d}\index{vdml.c@{vdml.c}!port\_mutex\_take\_all@{port\_mutex\_take\_all}}
\index{port\_mutex\_take\_all@{port\_mutex\_take\_all}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{port\_mutex\_take\_all()}{port\_mutex\_take\_all()}}
{\footnotesize\ttfamily \label{vdml_8c_a00133d1eced9193949574829587a393d} 
void port\+\_\+mutex\+\_\+take\+\_\+all (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Executes \doxylink{vdml_8h_a67513439eb7264d1196f58dbaa03c847}{port\+\_\+mutex\+\_\+take()} for all of the V5 Smart Ports. \Hypertarget{vdml_8c_aee1773d8eb981f08d1c33618106134ce}\index{vdml.c@{vdml.c}!vdml\_background\_processing@{vdml\_background\_processing}}
\index{vdml\_background\_processing@{vdml\_background\_processing}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{vdml\_background\_processing()}{vdml\_background\_processing()}}
{\footnotesize\ttfamily \label{vdml_8c_aee1773d8eb981f08d1c33618106134ce} 
void vdml\+\_\+background\+\_\+processing (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Background processing function for the VDML system.

This function should be called by the system daemon approximately every 2 milliseconds.

Updates the registry type array, detecting what devices are actually plugged in according to the system, then compares that with the registry records.

On warnings, no operation is performed. \Hypertarget{vdml_8c_a9b8bc94d616e0f915c2930698e64c4bc}\index{vdml.c@{vdml.c}!vdml\_get\_port\_error@{vdml\_get\_port\_error}}
\index{vdml\_get\_port\_error@{vdml\_get\_port\_error}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{vdml\_get\_port\_error()}{vdml\_get\_port\_error()}}
{\footnotesize\ttfamily \label{vdml_8c_a9b8bc94d616e0f915c2930698e64c4bc} 
bool vdml\+\_\+get\+\_\+port\+\_\+error (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{port}{}\end{DoxyParamCaption})}

Gets the error bit for the port, indicating whether or not there has been an error on this port.


\begin{DoxyParams}{Parameters}
{\em port} & The V5 port number to check from 0-\/20\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the port\textquotesingle{}s bit is set, false otherwise. 
\end{DoxyReturn}
\Hypertarget{vdml_8c_a285725607b31dfc76174f7e4569c3f84}\index{vdml.c@{vdml.c}!vdml\_initialize@{vdml\_initialize}}
\index{vdml\_initialize@{vdml\_initialize}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{vdml\_initialize()}{vdml\_initialize()}}
{\footnotesize\ttfamily \label{vdml_8c_a285725607b31dfc76174f7e4569c3f84} 
void vdml\+\_\+initialize (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Shorcut to initialize all of VDML (mutexes and register) \Hypertarget{vdml_8c_ab164b06ea2d6c77fac6d1afc8bfa78f4}\index{vdml.c@{vdml.c}!vdml\_set\_port\_error@{vdml\_set\_port\_error}}
\index{vdml\_set\_port\_error@{vdml\_set\_port\_error}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{vdml\_set\_port\_error()}{vdml\_set\_port\_error()}}
{\footnotesize\ttfamily \label{vdml_8c_ab164b06ea2d6c77fac6d1afc8bfa78f4} 
void vdml\+\_\+set\+\_\+port\+\_\+error (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{port}{}\end{DoxyParamCaption})}

Sets the port\textquotesingle{}s bit to 1, indicating there has already been an error on this port.


\begin{DoxyParams}{Parameters}
{\em port} & The V5 port number to set from 0-\/20 \\
\hline
\end{DoxyParams}
\Hypertarget{vdml_8c_a041f91b4d998392918864e26df946f32}\index{vdml.c@{vdml.c}!vdml\_unset\_port\_error@{vdml\_unset\_port\_error}}
\index{vdml\_unset\_port\_error@{vdml\_unset\_port\_error}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{vdml\_unset\_port\_error()}{vdml\_unset\_port\_error()}}
{\footnotesize\ttfamily \label{vdml_8c_a041f91b4d998392918864e26df946f32} 
void vdml\+\_\+unset\+\_\+port\+\_\+error (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{port}{}\end{DoxyParamCaption})}

Sets the port\textquotesingle{}s bit to 0, effectively resetting it.


\begin{DoxyParams}{Parameters}
{\em port} & The V5 port number to unset from 0-\/20 \\
\hline
\end{DoxyParams}


\doxysubsection{Variable Documentation}
\Hypertarget{vdml_8c_a93dbe5adaa0d9331b7a02a713da023c1}\index{vdml.c@{vdml.c}!port\_errors@{port\_errors}}
\index{port\_errors@{port\_errors}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{port\_errors}{port\_errors}}
{\footnotesize\ttfamily \label{vdml_8c_a93dbe5adaa0d9331b7a02a713da023c1} 
int32\+\_\+t port\+\_\+errors}

Bitmap to indicate if a port has had an error printed or not. \Hypertarget{vdml_8c_a234bd81f117a6313d45285d9fb6745f0}\index{vdml.c@{vdml.c}!port\_mutexes@{port\_mutexes}}
\index{port\_mutexes@{port\_mutexes}!vdml.c@{vdml.c}}
\doxysubsubsection{\texorpdfstring{port\_mutexes}{port\_mutexes}}
{\footnotesize\ttfamily \label{vdml_8c_a234bd81f117a6313d45285d9fb6745f0} 
\mbox{\hyperlink{group__c-rtos_gab15ea84d90257d70b44e8e04519864d2}{mutex\+\_\+t}} port\+\_\+mutexes\mbox{[}V5\+\_\+\+MAX\+\_\+\+DEVICE\+\_\+\+PORTS\mbox{]}}

We have V5\+\_\+\+MAX\+\_\+\+DEVICE\+\_\+\+PORTS so that we can do thread safety on things like controllers, batteries which are sort of like smart devices internally to the V5 